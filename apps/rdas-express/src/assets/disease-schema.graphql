interface AssociatedWithGeneProperties @relationshipProperties {
	AssociationStatus: String!
	AssociationType: String!
	Reference: [String]
}

type GARD {
	ClassificationLevel: String!
	DataSource: String!
	DataSourceId: String!
	DiseaseOntology: [String]
	DisorderType: [String]!
	GardId: String!
	GardName: String!
	GeneticAlliance: [String]
	GeneticsHomeReference: [String]
	ICD10: [String]
	ICD10CM: [String]
	ICD11: [String]
	MeSH: [String]
	MedDRA: [String]
	OMIM: [String]
	Orphanet: [String]
	SNOMEDCT: [String]
	Synonyms: [String]!
	UMLS: [String]
	associatedWithGeneGenes: [Gene!]! @relationship(type: "associated_with_gene", direction: OUT, properties: "AssociatedWithGeneProperties")
	gardSsubClassOf: [GARD!]! @relationship(type: "subClassOf", direction: IN)
	hasPhenotypePhenotypes: [Phenotype!]! @relationship(type: "has_phenotype", direction: OUT, properties: "HasPhenotypeProperties")
	subClassOfGards: [GARD!]! @relationship(type: "subClassOf", direction: OUT)
}

type Gene {
	Ensembl: String
	GeneIdentifier: String!
	GeneSymbol: String!
	GeneSynonyms: [String]
	GeneTitle: String!
	IUPHAR: String
	Locus: String!
	OMIM: String
	Reactome: String
	Swissprot: String
	gardSassociatedWithGene: [GARD!]! @relationship(type: "associated_with_gene", direction: IN, properties: "AssociatedWithGeneProperties")
}

interface HasPhenotypeProperties @relationshipProperties {
	Evidence: String!
	HPOFrequency: String
	Reference: [String]!
	ValidationStatus: Boolean!
}

type Phenotype {
	HPOId: String!
	HPOTerm: String!
	Modifier: [String]
	Online: Boolean!
	Onset: String
	Sex: String
	gardShasPhenotype: [GARD!]! @relationship(type: "has_phenotype", direction: IN, properties: "HasPhenotypeProperties")
}


scalar JSON

type GARDList {
  diseases: [GARD]!
  count: Int!
}


type Query {
  diseaseSearch(searchString: String): [GARD] @cypher(
    statement: """
      CALL db.index.fulltext.queryNodes(
        'allNameIndex', $searchString)
      YIELD node RETURN node LIMIT 10
    """
  )
}

type Query {
  treeParent: [JSON] @cypher(
    statement: """
    match (l:GARD)<-[s:subClassOf]-(:GARD) WHERE NOT (l:GARD)-[:subClassOf]->(:GARD)
    WITH {gardId: l.GardId, name: l.GardName, _childrenCount: COUNT(s)} as parents
    return collect(DISTINCT(parents))
    """
  )
}

type Query {
  treeBranch(searchString: String):[JSON] @cypher(
    statement: """
 match (l:GARD)<-[s:subClassOf]-(:GARD) WHERE NOT (l:GARD)-[:subClassOf]->(:GARD) WITH
  {gardId: l.GardId, name: l.GardName, _childrenCount: COUNT(s)} as parents
   match p=(:GARD {GardId: $searchString})-[r:subClassOf*0..]->(n:GARD) WHERE NOT (n:GARD)-[:subClassOf]->(:GARD)
    return {paths: collect(distinct(p)), nodes: collect(distinct(parents))}
 """
  )
}

type Query {
  treeBranchNew(searchString: String):[JSON] @cypher(
    statement: """
 MATCH (p:GARD {GardId: $searchString})
 CALL apoc.path.spanningTree(p, {
     relationshipFilter: "<subClassOf",
     labelFilter: "GARD"
 })
 YIELD path
 return {paths: collect(distinct(path)), nodes: collect(distinct(nodes(path)))}
 """
  )
}

type Query {
  hierarchyDiseases(searchString: String, limit: Int, skip: Int): [GARD] @cypher(
    statement: """
 match (d)-[*0..]->(e) WHERE e.GardId = $searchString
 with distinct(d) as ds
 SKIP $skip
 LIMIT $limit
 return ds
 """
  )
}

type Query {
  hierarchyDiseasesCount(searchString: String, limit: Int, skip: Int): Int @cypher(
  statement: """
 match (d)-[*0..]->(e) WHERE e.GardId = $searchString
 with count(distinct d) as count
 return count
 """
  )
}
