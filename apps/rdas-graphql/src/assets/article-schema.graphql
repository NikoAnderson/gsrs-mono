type Article {
	abstractText: String!
	affiliation: String!
	appearsInJournalVolumes: [JournalVolume!]! @relationship(type: "APPEARS_IN", direction: OUT)
	authorsWrote: [Author!]! @relationship(type: "WROTE", direction: IN)
	citedByCount: BigInt!
	diseasesMentionedIn: [Disease!]! @relationship(type: "MENTIONED_IN", direction: IN)
	doi: String!
	firstPublicationDate: String!
	fullTextUrlsContentFor: [FullTextUrl!]! @relationship(type: "CONTENT_FOR", direction: IN)
	hasOmimRefomimRefs: [OMIMRef!]! @relationship(type: "HAS_OMIM_REF", direction: OUT)
	hasPDF: String!
	inEPMC: String!
	inPMC: String!
	isEpi: String
	isOpenAccess: String!
	keywordsKeywordFor: [Keyword!]! @relationship(type: "KEYWORD_FOR", direction: IN)
	meshTermsMeshTermFor: [MeshTerm!]! @relationship(type: "MESH_TERM_FOR", direction: IN)
	omim_evidence: Boolean
	pubType: [String]
	pubmed_evidence: Boolean
	pubmed_id: String!
	pubtatorAnnotationsAnnotationFor: [PubtatorAnnotation!]! @relationship(type: "ANNOTATION_FOR", direction: IN)
	refInOMIM: Boolean
	source: String!
	substancesSubstanceAnnotatedByPubmed: [Substance!]! @relationship(type: "SUBSTANCE_ANNOTATED_BY_PUBMED", direction: IN)
	title: String!
}

type Author {
	firstName: String!
	fullName: String!
	lastName: String!
	wroteArticles: [Article!]! @relationship(type: "WROTE", direction: OUT)
}

type Disease {
	gard_id: String!
	is_rare: Boolean!
	mentionedInArticles: [Article!]! @relationship(type: "MENTIONED_IN", direction: OUT)
	name: String!
  all_ids: [String]
  all_names: [String]
  categories: [String]
  synonyms: [String]
}

type FullTextUrl {
	availability: String!
	availabilityCode: String!
	contentForArticles: [Article!]! @relationship(type: "CONTENT_FOR", direction: OUT)
	documentStyle: String!
	site: String!
	url: String!
}

type Journal {
	essn: String!
	issn: String!
	journalVolumesContentOf: [JournalVolume!]! @relationship(type: "CONTENT_OF", direction: IN)
	medlineAbbreviation: String!
	nlmid: String!
	title: String!
}

type JournalVolume {
	articlesAppearsIn: [Article!]! @relationship(type: "APPEARS_IN", direction: IN)
	contentOfJournals: [Journal!]! @relationship(type: "CONTENT_OF", direction: OUT)
	dateOfPublication: String!
	issue: String!
	journalIssueId: BigInt!
	monthOfPublication: BigInt!
	printPublicationDate: String!
	volume: String!
	yearOfPublication: BigInt!
}

type Keyword {
	keyword: String!
	keywordForArticles: [Article!]! @relationship(type: "KEYWORD_FOR", direction: OUT)
}

type MeshQualifier {
	abbreviation: String!
	majorTopic_YN: String!
	meshQualifierForMeshTerms: [MeshTerm!]! @relationship(type: "MESH_QUALIFIER_FOR", direction: OUT)
	qualifierName: String!
}

type MeshTerm {
	descriptorName: String!
	majorTopic_YN: String!
	meshQualifiersMeshQualifierFor: [MeshQualifier!]! @relationship(type: "MESH_QUALIFIER_FOR", direction: IN)
	meshTermForArticles: [Article!]! @relationship(type: "MESH_TERM_FOR", direction: OUT)
}

type OMIMRef {
	articlesHasOmimRef: [Article!]! @relationship(type: "HAS_OMIM_REF", direction: IN)
	omimId: String!
	omimName: String!
	omimSections: [String]!
}

type PubtatorAnnotation {
	annotationForArticles: [Article!]! @relationship(type: "ANNOTATION_FOR", direction: OUT)
	infons_identifier: String!
	infons_type: String!
	text: String!
	type: String!
}

type Substance {
	name: String!
	registryNumber: String!
	substanceAnnotatedByPubmedArticles: [Article!]! @relationship(type: "SUBSTANCE_ANNOTATED_BY_PUBMED", direction: OUT)
}

type Query {
  diseaseTypeahead(searchString: String): [Disease] @cypher(
    statement: """
      CALL db.index.fulltext.queryNodes(
        'allNameIndex', $searchString+'~')
      YIELD node RETURN node.name, node.gard_id
    """
  )
}

